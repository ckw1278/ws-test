'use strict';

const objectHelper = module.exports;

/**
 * 고귀하신 typeof 님은 숫자와 글자가 아닌 모든것을 object 로 보시는 만오평등 정책을 펼쳐왔다.
 * 이에 반기를 들고 각 오의 이름을 찾아주고자 한 이가 있었으니, 사람들은 그를 궷타입이라 창하였다.
 *
 * @param obj
 */
objectHelper.getType = function(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
};

/**
 * a 와 b 를 비교하여 다른 항목과 값(b의 값)을 리턴한다
 * 항목의 나열 숫자는 무시하고, 구성 항목의 갯수와 값이 같으면 같은 것으로 판단한다.
 *
 * @param exclude 비교 제외 항목, aaa.bb 형식으로 다층 구조의 안의 항목도 제외설정 가능
 * @return 서로 다른 항목 리턴, 모든 항목이 같으면 null 리턴
 */
objectHelper.compare = function(a, b, exclude, parentKey) {
  // b object deep clone 후 비교 제외 대상 항목 삭제
  b = this.deepClone(b);
  for(let key in b) {
    if(exclude && exclude.indexOf(key) !== -1) {
      delete b[key];
    }
  }

  const aType = objectHelper.getType(a);
  if(aType !== objectHelper.getType(b)) return b; // 데이터 형식이 다를 경우
  if(a === b) return null;

  let res = a.__proto__.constructor();

  if(aType === 'object') {
    for(let key of Object.keys(a)) {
      let val = a[key];

      // 비교제외 여부 체크
      const pathKey = parentKey ? parentKey + '.' + key : key;
      if(exclude && exclude.indexOf(pathKey) !== -1) continue;

      if(b.hasOwnProperty(key)) {
        if(val === b[key]) {
          delete b[key];
          continue;
        }

        if(/object|array/.test(this.getType(val))) {
          const rres = this.compare(val, b[key], exclude, pathKey);
          if(rres === null) { // 같으면
            delete b[key];
          } else {
            res[key] = rres;
          }
          continue;
        }
        res[key] = b[key];
      } else {
        res[key] = null;
      }
    }

    // b에 있는 항목이 a 에 없을 경우 b의 값 리턴
    Object.assign(res, b);

  } else if(aType === 'array') {
    if(a.length !== b.length) return b;

    for(let idx in a) {
      let val = a[idx];
      if(/object|array/.test(this.getType(val))) {
        const rres = this.compare(val, b[idx], exclude);
        if(rres !== null) res.push(rres);
      } else {
        if(b.indexOf(val) === -1) {
          res.push(b[idx]);
        }
      }
    }
  } else { // 지원하지 않는 타입
    return b;
  }

  return Object.keys(res).length ? res : null;
};

objectHelper.keyFilter = function(target, filter, result) {
  if(this.getType(result) === 'undefined') result = {};

  const type = objectHelper.getType(filter);
  if(this.getType(target) !== 'undefined') {
    if(type === 'string') {
      if(!target.hasOwnProperty(filter)) return;
      result[filter] = target[filter];
    } else if(type === 'object') {
      for(let key of Object.keys(filter)) {
        let val = filter[key];
        if(!target.hasOwnProperty(key) || target[key] === null) continue;
        if(objectHelper.getType(target[key]) === 'array') {
          result[key] = [];
          for(let obj of target[key]) {
            result[key].push(objectHelper.keyFilter(obj, val));
          }
        } else {
          result[key] = objectHelper.keyFilter(target[key], val);
        }
      }
    } else if(type === 'array') {
      for(let idx in filter) {
        objectHelper.keyFilter(target, filter[idx], result);
      }
    } else {
      return target;
    }
  }

  return result;
};

objectHelper.deepClone = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};

objectHelper.removeEmpty = function(object) {
  for(let k in object) {
    if(!object.hasOwnProperty(k)) continue;

    if(typeof object[k] === 'object') {
      this.removeEmpty(object[k]);
    }

    if(object[k] === '') {
      delete object[k];
    }
  }
};