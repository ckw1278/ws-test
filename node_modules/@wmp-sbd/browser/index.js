'use strict';

const config = require('@wmp-sbd/config');
const defer = require('@wmp-sbd/defer');
const URL = require('url').URL;
const async = require('async');
const request = require('request');
const fs = require('fs');
const path = require('path');
const im = require('@wmp-sbd/im');
const http = require('http');
const Iconv = require('iconv').Iconv;
const os = require('os');
const _ = require('underscore');
const cheerio = require('cheerio');
const pool = new http.Agent({
  keepAlive: true
});

const MAX_REDIRECTS = 3;
const BROWSER_AGENT = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36';
const DEFAULT_DOWNLOAD_TIMEOUT = 5000;
const DEFAULT_DOCUMENT_TIMEOUT = 3000;

class Browser {
  constructor() {
    // 프록시 목록 로딩
    try {
      this.enableProxy = config.get('browser.proxy.enable');
      if(this.enableProxy) {
        this.proxies = config.get('browser.proxy.servers');
      }
    } catch(e) {
      this.enableProxy = false;
    }

    // 문서 타임아웃 시간 설정
    try {
      this.downloadTimeout = config.get('browser.downloadTimeout');
    } catch(e) {
      this.downloadTimeout = DEFAULT_DOWNLOAD_TIMEOUT;
    }

    // 문서 열기 타입아웃 시간 설정
    try {
      this.documentTimeout = config.get('browser.documentTimeout');
    } catch(e) {
      this.documentTimeout = DEFAULT_DOCUMENT_TIMEOUT;
    }

    // 기본설정이 랩핑된 request 생성
    this.request = request.defaults({
      timeout: this.documentTimeout
    });
  }

  // 특정 페이지에서 condition 에 맞는 이미지 목록 추출
  extractImagesUris(documentUri, condition, callback) {
    this.open(documentUri).then((doc) => {
      // 문서 내 특정 DOM Element 에 대한 제외 규칙이 있을 경우 적용
      // 2018-08-07 allowedElements 추가. 해당 페이지에서 html tag를 잘못 배치해서, 제외 규칙이 적용되었을 때 구제하기 위함.
      if(condition && condition.banElements) {
        doc = this._removeElements(documentUri, doc, condition.banElements, condition.allowedElements);
      }

      // doc에서 html comment 부분 제외. 주석에 있는 image tag에 있는 이미지는 필요 없기 때문.
      doc = doc.toString().replace(/<!--([\s\S]*?)-->/gm, '');

      //  이미지 URI 추출
      let imageUris = [];
      const imgRegex = /<img.+?(src|original)=["']?(.+?)["'>]/gi;
      let imgMatches;
      while((imgMatches = imgRegex.exec(doc)) !== null) {
        imageUris.push(_.unescape(imgMatches[2]));
      }

      // 중복제거
      const uniqueImageUris = [];
      for(const uri of imageUris) {
        // html 문서에서 링크가 http://bsd2743.cafe24.com /wingsmall/codistyle/18/01/122/b.jpg 와 같이
        // url 형식에 맞지 않는 경우가 포함되어 있어서, try catch로 감쌌다.
        try {
          const absUri = new URL(uri, documentUri).href;
          if(uniqueImageUris.indexOf(absUri) !== -1) continue;
          uniqueImageUris.push(absUri);
        } catch(err) {}
      }

      // 확장자 체크 및 발견 우선순위 정보 주입
      let absImageUris = [];
      for(const pos in uniqueImageUris) {
        const uri = new URL(uniqueImageUris[pos]);
        const ext = uri.pathname.toLowerCase().split('.').pop();
        if(condition && condition.ext && condition.ext.indexOf(ext) === -1) continue;

        absImageUris.push({uri: uri, position: pos});
      }

      // condition.banUris(수집 제외 URI 패턴) 컨디션 확인
      if(condition && condition.banUris) {
        const filteredUris = [];
        for(const item of absImageUris) {
          if(this._testUri(item.uri, condition.banUris)) continue;

          filteredUris.push(item);
        }

        absImageUris = filteredUris;
      }

      // 비동기 처리가 필요한 컨디션 체크
      async.series([
        (next) => { // chk minSize
          if(!condition || !condition.minSize) return next();

          const filteredUris = [];
          async.each(absImageUris, (item, nextUri) => {
            this.getRemoteFileSize(item.uri, (err, fileSize) => {
              if(err) return nextUri();  // URI를 열지 못한 경우 패스
              if(fileSize !== null && fileSize < condition.minSize) return nextUri(); // 파일크기 확인에 성공한 경우에 한하여 체크

              Object.assign(item, {fileSize: fileSize});
              filteredUris.push(item);

              nextUri();
            });
          }, (err) => {
            if(err) return next(err);
            imageUris = filteredUris;
            next();
          });
        }

        // ... 추가가 필요한 경우.

      ], (err) => {
        if(err) return callback(err);
        // 제외된 파일을 제외하고 position 을 재 정렬하여 리턴
        imageUris.sort((a,b) => {
          return a['position'] - b['position'];
        });

        const sortedList = [];
        for(const pos in imageUris) {
          imageUris[pos]['position'] = pos;
          sortedList.push(imageUris[pos]);
        }
        callback(null, imageUris);
      });
    }, (err) => {
      return callback(err);
    });
  }

  async downloadToTmp(uri, referrer, callback) {
    const tmpPath = await this._tmpFile();
    return defer(this, this.download)(uri, tmpPath, referrer);
  }

  download(uri, dstPath, referrer, callback) {
    if(!(this instanceof URL)) uri = new URL(uri);
    if(typeof referrer === 'function') {
      callback = referrer;
      referrer = null;
    }
    const params = {
      method: 'GET',
      uri: uri,
      jar: request.jar(), // 쿠키를 통한 리다이렉트에 대응하기위해 1회성 쿠키 스토어 생성
      maxRedirects: MAX_REDIRECTS,
      headers: {},
      pool: pool,
      timeout: this.downloadTimeout
    };

    // proxy
    if(this.enableProxy) params.proxy = this._pickProxy();
    if(referrer) params.headers.referer = referrer;


    const srcStream = this.request(params);
    srcStream.pause();
    srcStream.on('response', (resp) => {
      if(resp.statusCode === 200) {

        const dstStream = fs.createWriteStream(dstPath);
        dstStream.on('finish', () => {
          callback(null, dstPath);
        });

        srcStream.pipe(dstStream);
        srcStream.resume();

      } else {
        const err = new Error(`HTTP(${resp.statusCode})`);
        err.uri = params.uri;
        return callback(err);
      }
    });
    srcStream.on('error', (err) => {
      err.uri = params.uri;
      return callback(err);
    });
  }

  open(uri, encoding = 'UTF-8', agent = null) {
    return new Promise((resolve, reject) => {
      const params = {
        uri: uri,
        jar: request.jar(), // 쿠키를 통한 리다이렉트에 대응하기위해 1회성 쿠키 스토어 생성
        headers: {
          pool: pool,
          maxRedirects: MAX_REDIRECTS,
          'User-Agent': agent ? agent : BROWSER_AGENT
        },
        encoding: 'binary'
      };

      // proxy
      if(this.enableProxy) params.proxy = this._pickProxy();

      this.request(params, (err, response, body) => {
        if(err) return reject(err);

        const doc = body.toString();
        const redirectMeta = /<meta http-equiv=["']refresh['"].*url=[\\]?.*?['"](.*?)['"]/gmi.exec(doc);
        if(redirectMeta) {
          let redirectUri;
          try {
            redirectUri = new URL(redirectMeta[1], response.request.uri.href);
          } catch(e) {}

          if(redirectUri) {
            this.open(redirectUri.href, encoding, agent).then(resolve, reject);
            return;
          }
        }

        // 지정된 캐릭터셋으로 인코딩
        if(encoding) {
          const binaryBody = new Buffer(body, 'binary'); // 바이너리로 다루어 인코딩 오류 방지
          let docCharacterSet = this._documentCharset(doc) || 'UTF-8';

          // 캐릭터셋 변경 후 리턴
          const iconv = new Iconv(docCharacterSet, `${encoding}//TRANSLIT//IGNORE`);
          resolve(iconv.convert(binaryBody));
        } else {
          resolve(body);
        }
      });
    });
  }

  async downloadAndConvert(imageUri, referrer = null, ext = 'jpg', quality = '80') {
    const tmpFolder = await this._tmpDir();

    // 다운로드
    const tmpPath = `${tmpFolder}/dst`;
    await defer(this, this.download)(imageUri, tmpPath, referrer);

    // 컨버트
    const resPath = `${tmpFolder}/res.${ext}`;
    await defer(this, im.convert)([tmpPath + '[0]','-quality', quality, resPath]); // ANIGIF 일 경우 첫 프레임만 추출

    // 정보 확인
    const id = await defer(this, im.identify)(resPath);

    return {
      path: resPath,
      width: id.width,
      height: id.height,
      filesize: parseInt(id.filesize)
    };
  }

  getRemoteFileSize(uri, callback) {
    const params = {
      method: 'HEAD',
      uri: uri,
      maxRedirects: MAX_REDIRECTS,
      pool: pool,
    };

    // proxy
    if(this.enableProxy) params.proxy = this._pickProxy();

    this.request(params, (err, res) => {
      if(err) return callback(new Error(`URI open failed : ${uri}`));

      // CDN, Proxy 등에서 HEAD method 를 지원하지 않는 경우가 있음
      if(res.statusCode === 200) { // 따라서 200인 경우에만 컨텐츠 길이를 리턴
        callback(null, res.headers['content-length']);
      } else if(res.statusCode === 404) { // 404 인 경우 에러를 리턴
        return callback(new Error(`URI open failed(404) : ${uri}`));
      } else { // 그 외의 경우는 null 을 리턴
        return callback(null, null);
      }
    });
  }

  /**
   * 프록시 서버 중 하나를 랜덤하게 선택한다
   */
  _pickProxy() {
    if(!this.proxies.length) return null;
    const targetPos = Math.floor(Math.random() * this.proxies.length);
    return this.proxies[targetPos];
  }

  async _tmpDir() {
    let tmpPath;
    try {
      tmpPath = config.get('tmp.path');
    } catch(e) {
      tmpPath = os.tmpdir();
    }

    return await defer(fs, fs.mkdtemp)(path.join(tmpPath, 'browser-'));
  }

  async _tmpFile() {
    return await this._tmpDir() + '/tmp';
  }

  _documentCharset(html) {
    const res = html.match(/<meta.+charset=([^\s"]+)/i);
    if(!res) return null;

    const charset = res[1].toUpperCase();
    if(charset === 'KS_C_5601-1987') return 'EUC-KR'; // M$님께서 창제하신 확장완성형 캐릭터셋 예외처리
    else return charset;
  }

  _removeElements(documentUri, doc, banElements, allowedElements) {
    const $ = cheerio.load(doc, {decodeEntities: false});
    let shouldRemoveSelectors = [];
    for(const uriPtrn in banElements) {
      if(uriPtrn !== '*' && !new RegExp(uriPtrn, 'i').test(documentUri)) continue;

      for(const selector of banElements[uriPtrn]) {
        if(process.env.DEBUG) console.log(selector + '\t:\t' + $(selector).length);
        // $(selector).remove();
        shouldRemoveSelectors.push(selector);
      }
    }
    let shouldSaveSelectors = [];
    for(const uriPtrn in allowedElements) {
      if(uriPtrn !== '*' && !new RegExp(uriPtrn, 'i').test(documentUri)) continue;

      for(const selector of allowedElements[uriPtrn]) {
        if(process.env.DEBUG) console.log(selector + '\t:\t' + $(selector).length);
        shouldSaveSelectors.push(selector);
      }
    }

    shouldRemoveSelectors = shouldRemoveSelectors.filter(item => !shouldSaveSelectors.includes(item));
    shouldRemoveSelectors.forEach((elem, idx, array) => {
      $(elem).remove();
    });

    return $.html();
  }

  _testUri(uri, ptrns) {
    for(const ptrn of ptrns) {
      if(ptrn.test(uri)) return true;
    }

    return false;
  }
}

module.exports = new Browser();
